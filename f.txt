TO RUN THE FILES:

Step 1: Install flex or lex 
sudo apt-get update
sudo apt-get install gcc 
sudo apt-get install lex
sudo apt-get install bison
sudo apt-get install flex

Step 2: to run c file:
gcc file.c –o file.out
./file.out

Step 3: To run lex file:                          Step 4: To run yacc files:    
lex lexfile.l OR flex lexfile.l 			 yacc -d yaccfile.y
gcc lex.yy.c –o lex.out					 lex lexfile.l
./lex.out							gcc lex.yy.c y.tab.c
								./a.out



1.a. YACC program for Binary to Decimal Conversion

lex(save as .l)

%{ 
  /* Definition section */
  #include<stdio.h> 
  #include<stdlib.h> 
  #include"y.tab.h" 
  extern int yylval; 
%} 
  
/* Rule Section */
 %% 
 0 {yylval=0;return ZERO;} 
 1 {yylval=1;return ONE;} 
   
 [ \t] {;} 
 \n return 0; 
 . return yytext[0]; 
%% 
  
    
int yywrap()   
 {   
  return 1;   
 }  


yacc(save as .y) 


%{ 
  /* Definition section */
  #include<stdio.h> 
  #include<stdlib.h> 
  void yyerror(char *s); 
%} 
%token ZERO ONE 
  
/* Rule Section */
%% 
N: L {printf("\n%d", $$);} 
L: L B {$$=$1*2+$2;} 
| B {$$=$1;} 
B:ZERO {$$=$1;} 
|ONE {$$=$1;}; 
%% 
  
//driver code  
int main() 
{ 
 while(yyparse()); 
} 
  
yyerror(char *s) 
{ 
 fprintf(stdout, "\n%s", s); 
} 

---------------------------------------------------------------------------------------------------------------
1.b. write a c Program to implement semantic rules to calculate the expression that takes an expression with digits, + and * and computes the value.

#include <stdio.h>

// function to calculate the value of an expression
int calculate(char *expression) {
    int num = 0; // to store the current number being read
    int result = 0; // to store the final result
    char op = '+'; // to store the current operator
    
    while (*expression) {
        if (*expression >= '0' && *expression <= '9') {
            num = num * 10 + (*expression - '0'); // build the current number
        } else if (*expression == '+' || *expression == '*') {
            // apply the previous operator and update the current operator
            if (op == '+') {
                result += num;
            } else {
                result *= num;
            }
            op = *expression;
            num = 0; // reset the current number
        }
        expression++; // move to the next character
    }
    if (op == '+') {
        result += num;
    } else {
        result *= num;
    }
    return result;
}

// test the program
int main() {
    char expression[100];
    printf("Enter an expression: ");
    scanf("%s", expression);
    int result = calculate(expression);
    printf("Result: %d\n", result);
    return 0;
}

____________________________________________________________________________________________________________________________________________________________________

2.a. YACC program to check whether given string is Palindrome or not.

lex code 

%{ 
    /* Definition section */
    #include <stdio.h> 
    #include <stdlib.h> 
    #include "y.tab.h" 
%} 
  
/* %option noyywrap */
  
/* Rule Section */
%% 
  
[a-zA-Z]+   {yylval.f = yytext; return STR;} 
[-+()*/]    {return yytext[0];} 
[ \t\n]      {;} 
  
%% 
  
 int yywrap() 
 {  
  return -1;  
 }   

yacc code - 

%{ 
    /* Definition section */
    #include <stdio.h> 
    #include <string.h>    
    #include <stdlib.h> 
    extern int yylex(); 
     
    void yyerror(char *msg); 
    int flag; 
     
    int i; 
    int k =0;        
%} 
  
%union { 
    char* f; 
 } 
  
%token <f> STR 
%type <f> E 
  
/* Rule Section */
%% 
  
S : E    { 
         flag = 0; 
         k = strlen($1) - 1; 
         if(k%2==0){    
           
         for (i = 0; i <= k/2; i++) { 
           if ($1[i] == $1[k-i]) { 
            } else { 
               flag = 1; 
              } 
          } 
         if (flag == 1) printf("Not palindrome\n"); 
         else printf("palindrome\n"); 
         printf("%s\n", $1); 
           
        }else{ 
          
        for (i = 0; i < k/2; i++) { 
          if ($1[i] == $1[k-i]) { 
          } else { 
              flag = 1; 
             } 
            } 
        if (flag == 1) printf("Not palindrome\n"); 
        else printf("palindrome\n"); 
        printf("%s\n", $1);            
         
  
          } 
       } 
  ; 
  
E :  STR    {$$ = $1;} 
  ; 
  
%% 
  
void yyerror(char *msg) 
 { 
    fprintf(stderr, "%s\n", msg); 
    exit(1); 
 } 
  
//driver code  
int main() 
 { 
    yyparse(); 
    return 0; 
 } 

--------------------------------------------------------------------------------------------------------------------------------------------
2.b  code generation 


#include<stdio.h>
#include<ctype.h>
typedef struct
{ char var[10];
int alive;
}
regist;
regist preg[10];
void substring(char exp[],int st,int end)
{ int i,j=0;
char dup[10]="";
for(i=st;i
dup[j++]=exp[i];
dup[j]='0';
strcpy(exp,dup);
} int getregister(char var[])
{ int i;
for(i=0;i<10;i++)
{
if(preg[i].alive==0)
{
strcpy(preg[i].var,var);
break;
}}
return(i);
}
void getvar(char exp[],char v[])
{ int i,j=0;
char var[10]="";
for(i=0;exp[i]!='\0';i++)
if(isalpha(exp[i]))
var[j++]=exp[i];
else
break;
strcpy(v,var);
}
void main()
{ char basic[10][10],var[10][10],fstr[10],op;
int i,j,k,reg,vc,flag=0;
clrscr();
printf("\nEnter the Three Address Code:\n");
for(i=0;;i++)
{
gets(basic[i]);
if(strcmp(basic[i],"exit")==0)
break;
}
printf("\nThe Equivalent Assembly Code is:\n");
for(j=0;j
{
getvar(basic[j],var[vc++]);
strcpy(fstr,var[vc-1]);
substring(basic[j],strlen(var[vc-1])+1,strlen(basic[j]));
getvar(basic[j],var[vc++]);
reg=getregister(var[vc-1]);
if(preg[reg].alive==0)
{
printf("\nMov R%d,%s",reg,var[vc-1]);
preg[reg].alive=1;
}
op=basic[j][strlen(var[vc-1])];
substring(basic[j],strlen(var[vc-1])+1,strlen(basic[j]));
getvar(basic[j],var[vc++]);
switch(op)
{ case '+': printf("\nAdd"); break;
case '-': printf("\nSub"); break;
case '*': printf("\nMul"); break;
case '/': printf("\nDiv"); break;
}
flag=1;
for(k=0;k<=reg;k++)
{ if(strcmp(preg[k].var,var[vc-1])==0)
{
printf("R%d, R%d",k,reg);
preg[k].alive=0;
flag=0;
break;
}} if(flag)
{
printf(" %s,R%d",var[vc-1],reg);
printf("\nMov %s,R%d",fstr,reg);
}strcpy(preg[reg].var,var[vc-3]);
getch();
}}

_____________________________________________________________________________________________________________________________________

3.a FIRST of a Given Grammar using C program

#include<stdio.h>
#include<ctype.h>
void FIRST(char[],char );
void addToResultSet(char[],char);
int numOfProductions;
char productionSet[10][10];
main()
{
    int i;
    char choice; 
    char c;
    char result[20];
    printf("How many number of productions ? :");
    scanf(" %d",&numOfProductions);
    for(i=0;i<numOfProductions;i++)//read production string eg: E=E+T
    {
        printf("Enter productions Number %d : ",i+1);
        scanf(" %s",productionSet[i]);
    }
    do
    {
        printf("\n Find the FIRST of  :");
        scanf(" %c",&c);
        FIRST(result,c); //Compute FIRST; Get Answer in 'result' array
        printf("\n FIRST(%c)= { ",c);
        for(i=0;result[i]!='\0';i++)
        printf(" %c ",result[i]);       //Display result
        printf("}\n");
         printf("press 'y' to continue : ");
        scanf(" %c",&choice);
    }
    while(choice=='y'||choice =='Y');
}
/*
 *Function FIRST:
 *Compute the elements in FIRST(c) and write them
 *in Result Array.
 */
void FIRST(char* Result,char c)
{
    int i,j,k;
    char subResult[20];
    int foundEpsilon;
    subResult[0]='\0';
    Result[0]='\0';
    //If X is terminal, FIRST(X) = {X}.
    if(!(isupper(c)))
    {
        addToResultSet(Result,c);
               return ;
    }
    //If X is non terminal
    //Read each production
    for(i=0;i<numOfProductions;i++)
    {
//Find production with X as LHS
        if(productionSet[i][0]==c)
        {
//If X → ε is a production, then add ε to FIRST(X).
 if(productionSet[i][2]=='$') addToResultSet(Result,'$');
            //If X is a non-terminal, and X → Y1 Y2 … Yk
            //is a production, then add a to FIRST(X)
            //if for some i, a is in FIRST(Yi),
            //and ε is in all of FIRST(Y1), …, FIRST(Yi-1).
      else
            {
                j=2;
                while(productionSet[i][j]!='\0')
                {
                foundEpsilon=0;
                FIRST(subResult,productionSet[i][j]);
                for(k=0;subResult[k]!='\0';k++)
                    addToResultSet(Result,subResult[k]);
                 for(k=0;subResult[k]!='\0';k++)
                     if(subResult[k]=='$')
                     {
                         foundEpsilon=1;
                         break;
                     }
                 //No ε found, no need to check next element
                 if(!foundEpsilon)
                     break;
                 j++;
                }
            }
    }
}
    return ;
}
/* addToResultSet adds the computed
 *element to result set. 
 *This code avoids multiple inclusion of elements
  */
void addToResultSet(char Result[],char val)
{
    int k;
    for(k=0 ;Result[k]!='\0';k++)
        if(Result[k]==val)
            return;
    Result[k]=val;
    Result[k+1]='\0';
}

output - 
How many productions? 8

Enter 8 productions:

E = TD
D=+TD
D=$
T=FS
S=*FS
S=$
F=(E)
F=a


output
FIRST (E) = FIRST (T) =FIRST (F) = { ( , a}
FIRST (D) = { + , ε }
FIRST (S)= { * , ε }


-----------------------------------------------------------------------------------------------------------------------------

3.b. Lex program to take input from file and remove multiple spaces, lines and tabs

/*Lex program to take input from file and 
remove multiple spaces, newline and tab
and write output in a separate file*/

% {
	/*Definition section */
	%
}

/* Rule: whenever space, tab or 
newline is encountered, remove it*/
% %
[ \n\t]+ {fprintf(yyout, "%s");}
.	 { fprintf(yyout, "%s", yytext); }
% %



// driver code 
int main()
{

	/* yyin and yyout as pointer
	of File type */
	extern FILE *yyin, *yyout;

	/* yyin points to the file input.txt
	and opens it in read mode*/
	yyin = fopen("Input.txt", "r");

	/* yyout points to the file output.txt
	and opens it in write mode*/
	yyout = fopen("Output.txt", "w");

	yylex();
	return 0;
}


_______________________________________________________________________________________________________________________________________

4.a FOLLOW OF GIVEN GRAMMAR USING C PROGRAM


#include<stdio.h>
#include<string.h>
int n,m=0,p,i=0,j=0;
char a[10][10],followResult[10];
void follow(char c);
void first(char c);
void addToResult(char);
int main()
{
 int i;
 int choice;
 char c,ch;
 printf("Enter the no.of productions: ");
scanf("%d", &n);
 printf(" Enter %d productions\nProduction with multiple terms should be give as separate productions \n", n);
 for(i=0;i<n;i++)
  scanf("%s%c",a[i],&ch);
    // gets(a[i]);
 do
 {
  m=0;
  printf("Find FOLLOW of -->");
  scanf(" %c",&c);
  follow(c);
  printf("FOLLOW(%c) = { ",c);
  for(i=0;i<m;i++)
   printf("%c ",followResult[i]);
  printf(" }\n");
  printf("Do you want to continue(Press 1 to continue....)?");
 scanf("%d%c",&choice,&ch);
 }
 while(choice==1);
}
void follow(char c)
{
    if(a[0][0]==c)addToResult('$');
 for(i=0;i<n;i++)
 {
  for(j=2;j<strlen(a[i]);j++)
  {
   if(a[i][j]==c)
   {
    if(a[i][j+1]!='\0')first(a[i][j+1]);
    if(a[i][j+1]=='\0'&&c!=a[i][0])
     follow(a[i][0]);
   }
  }
 }
}
void first(char c)
{
      int k;
                 if(!(isupper(c)))
                     //f[m++]=c;
                     addToResult(c);
                 for(k=0;k<n;k++)
                 {
                 if(a[k][0]==c)
                 {
                 if(a[k][2]=='$') follow(a[i][0]);
                 else if(islower(a[k][2]))
                     //f[m++]=a[k][2];
                     addToResult(a[k][2]);
                 else first(a[k][2]);
                 }
                 }
}
void  addToResult(char c)
{
    int i;
    for( i=0;i<=m;i++)
        if(followResult[i]==c)
            return;
   followResult[m++]=c;
}

--------------------------------------------------------------------------------------------------------------------------------------
4.b.  follow of given grammer in c


#include <ctype.h>
#include <stdio.h>
#include <string.h>
 
// Functions to calculate Follow
void followfirst(char, int, int);
void follow(char c);
 
// Function to calculate First
void findfirst(char, int, int);
 
int count, n = 0;
 
// Stores the final result
// of the First Sets
char calc_first[10][100];
 
// Stores the final result
// of the Follow Sets
char calc_follow[10][100];
int m = 0;
 
// Stores the production rules
char production[10][10];
char f[10], first[10];
int k;
char ck;
int e;
 
int main(int argc, char** argv)
{
    int jm = 0;
    int km = 0;
    int i, choice;
    char c, ch;
    count = 8;
 
    // The Input grammar
    strcpy(production[0], "X=TnS");
    strcpy(production[1], "X=Rm");
    strcpy(production[2], "T=q");
    strcpy(production[3], "T=#");
    strcpy(production[4], "S=p");
    strcpy(production[5], "S=#");
    strcpy(production[6], "R=om");
    strcpy(production[7], "R=ST");
 
    int kay;
    char done[count];
    int ptr = -1;
 
    // Initializing the calc_first array
    for (k = 0; k < count; k++) {
        for (kay = 0; kay < 100; kay++) {
            calc_first[k][kay] = '!';
        }
    }
    int point1 = 0, point2, xxx;
 
    for (k = 0; k < count; k++) {
        c = production[k][0];
        point2 = 0;
        xxx = 0;
 
        // Checking if First of c has
        // already been calculated
        for (kay = 0; kay <= ptr; kay++)
            if (c == done[kay])
                xxx = 1;
 
        if (xxx == 1)
            continue;
 
        // Function call
        findfirst(c, 0, 0);
        ptr += 1;
 
        // Adding c to the calculated list
        done[ptr] = c;
        printf("\n First(%c) = { ", c);
        calc_first[point1][point2++] = c;
 
        // Printing the First Sets of the grammar
        for (i = 0 + jm; i < n; i++) {
            int lark = 0, chk = 0;
 
            for (lark = 0; lark < point2; lark++) {
 
                if (first[i] == calc_first[point1][lark]) {
                    chk = 1;
                    break;
                }
            }
            if (chk == 0) {
                printf("%c, ", first[i]);
                calc_first[point1][point2++] = first[i];
            }
        }
        printf("}\n");
        jm = n;
        point1++;
    }
    printf("\n");
    printf("-----------------------------------------------"
           "\n\n");
    char donee[count];
    ptr = -1;
 
    // Initializing the calc_follow array
    for (k = 0; k < count; k++) {
        for (kay = 0; kay < 100; kay++) {
            calc_follow[k][kay] = '!';
        }
    }
    point1 = 0;
    int land = 0;
    for (e = 0; e < count; e++) {
        ck = production[e][0];
        point2 = 0;
        xxx = 0;
 
        // Checking if Follow of ck
        // has already been calculated
        for (kay = 0; kay <= ptr; kay++)
            if (ck == donee[kay])
                xxx = 1;
 
        if (xxx == 1)
            continue;
        land += 1;
 
        // Function call
        follow(ck);
        ptr += 1;
 
        // Adding ck to the calculated list
        donee[ptr] = ck;
        printf(" Follow(%c) = { ", ck);
        calc_follow[point1][point2++] = ck;
 
        // Printing the Follow Sets of the grammar
        for (i = 0 + km; i < m; i++) {
            int lark = 0, chk = 0;
            for (lark = 0; lark < point2; lark++) {
                if (f[i] == calc_follow[point1][lark]) {
                    chk = 1;
                    break;
                }
            }
            if (chk == 0) {
                printf("%c, ", f[i]);
                calc_follow[point1][point2++] = f[i];
            }
        }
        printf(" }\n\n");
        km = m;
        point1++;
    }
}
 
void follow(char c)
{
    int i, j;
 
    // Adding "$" to the follow
    // set of the start symbol
    if (production[0][0] == c) {
        f[m++] = '$';
    }
    for (i = 0; i < 10; i++) {
        for (j = 2; j < 10; j++) {
            if (production[i][j] == c) {
                if (production[i][j + 1] != '\0') {
                    // Calculate the first of the next
                    // Non-Terminal in the production
                    followfirst(production[i][j + 1], i,
                                (j + 2));
                }
 
                if (production[i][j + 1] == '\0'
                    && c != production[i][0]) {
                    // Calculate the follow of the
                    // Non-Terminal in the L.H.S. of the
                    // production
                    follow(production[i][0]);
                }
            }
        }
    }
}
 
void findfirst(char c, int q1, int q2)
{
    int j;
 
    // The case where we
    // encounter a Terminal
    if (!(isupper(c))) {
        first[n++] = c;
    }
    for (j = 0; j < count; j++) {
        if (production[j][0] == c) {
            if (production[j][2] == '#') {
                if (production[q1][q2] == '\0')
                    first[n++] = '#';
                else if (production[q1][q2] != '\0'
                         && (q1 != 0 || q2 != 0)) {
                    // Recursion to calculate First of New
                    // Non-Terminal we encounter after
                    // epsilon
                    findfirst(production[q1][q2], q1,
                              (q2 + 1));
                }
                else
                    first[n++] = '#';
            }
            else if (!isupper(production[j][2])) {
                first[n++] = production[j][2];
            }
            else {
                // Recursion to calculate First of
                // New Non-Terminal we encounter
                // at the beginning
                findfirst(production[j][2], j, 3);
            }
        }
    }
}
 
void followfirst(char c, int c1, int c2)
{
    int k;
 
    // The case where we encounter
    // a Terminal
    if (!(isupper(c)))
        f[m++] = c;
    else {
        int i = 0, j = 1;
        for (i = 0; i < count; i++) {
            if (calc_first[i][0] == c)
                break;
        }
 
        // Including the First set of the
        // Non-Terminal in the Follow of
        // the original query
        while (calc_first[i][j] != '!') {
            if (calc_first[i][j] != '#') {
                f[m++] = calc_first[i][j];
            }
            else {
                if (production[c1][c2] == '\0') {
                    // Case where we reach the
                    // end of a production
                    follow(production[c1][0]);
                }
                else {
                    // Recursion to the next symbol
                    // in case we encounter a "#"
                    followfirst(production[c1][c2], c1,
                                c2 + 1);
                }
            }
            j++;
        }
    }
}

_________________________________________________________________________________________________________________________________________________


5-a  C program to check given grammar is Regular Grammar or not


C code for Regular Grammar
/* C program to check given grammar is Regular Grammar or not. */


#include<stdio.h>
#include<string.h>

int i,j,k,l,m,n=0,o,p,nv,z=0,t,x=0;
char str[10],temp[10],temp2[10],temp3[10];

struct prod
{
    char lhs[10],rhs[10][10];
    int n;
}pro[10];

void findter()
{
    for(k=0;k<n;k++)
    {
        if(temp[i]==pro[k].lhs[0])
        {
            for(t=0;t<pro[k].n;t++)
            {
                for(x=0;x<10;x++)
                    temp2[x]='\0';
                for(l=i+1;l<strlen(temp);l++)
                    temp2[l-i-1]=temp[l];
                temp[i]='\0';
                for(l=0;l<strlen(pro[k].rhs[t]);l++)
                    temp[i+l]=pro[k].rhs[t][l];
                strcat(temp,temp2);
                if(str[i]==temp[i])
                    return;
            }
        }
    }
    
}

void main()
{
    FILE *f;

    for(i=0;i<10;i++)
        pro[i].n=0;

    f=fopen("tab3.txt","r");
    while(!feof(f))
    {
        fscanf(f,"%s",pro[n].lhs);
        if(n>0)
        {
            if( strcmp(pro[n].lhs,pro[n-1].lhs) == 0 )
            {
                pro[n].lhs[0]='\0';
                fscanf(f,"%s",pro[n-1].rhs[pro[n-1].n]);
                pro[n-1].n++;
                continue;
            }
        }
        fscanf(f,"%s",pro[n].rhs[pro[n].n]);
        pro[n].n++;
        n++;
    }
    n--;

    printf("\n\nTHE GRAMMAR IS AS FOLLOWS\n\n");
    for(i=0;i<n;i++)
        for(j=0;j<pro[i].n;j++)
            printf("%s -> %s\n",pro[i].lhs,pro[i].rhs[j]);

    o=0;
    for(i=0;i<n;i++)
    {
        for(j=0;j<pro[i].n;j++)
            if( pro[i].rhs[j][0]>=65 && pro[i].rhs[j][0]<=90 )
            {
                o=1;
                break;
            }
        if(o==1)
            break;
    }
    if(i==n)
        printf("\n\nTHE GRAMMAR is a REGULAR GRAMMAR !!!");
    else
    {
        printf("\n\nTHE GRAMMAR is NOT a REGULAR GRAMMAR !!!");
        exit(1);
    }

    while(1)
    {
        for(x=0;x<10;x++)
            str[x]='\0';
        printf("\n\nENTER ANY STRING ( 0 for EXIT ) : ");
        scanf("%s",str);
        if(str[0]=='0')
            exit(1);

        for(j=0;j<pro[0].n;j++)
        {
            for(x=0;x<10;x++)
                temp[x]='\0';
            strcpy(temp,pro[0].rhs[j]);

            m=0;
            for(i=0;i<strlen(str);i++)
            {
                if(str[i]==temp[i])
                    m++;
                else if(str[i]!=temp[i] && temp[i]>=65 && temp[i]<=90)
                {
                    findter();
                    if(str[i]==temp[i])
                        m++;
                }
            }
            for(x=0;x<10;x++)
                temp3[x]='\0';
            strcpy(temp3,temp);
            temp3[strlen(temp)-1]='\0';
            //printf("%s",temp);
            if(m==strlen(str) && strcmp(temp3,str)==0 && strlen(temp3)!=1)
            {
                printf("\n\nTHE STRING can be PARSED !!!");
                break;
            }
            if(m==strlen(str) && strlen(str)==strlen(temp))
            {
                printf("\n\nTHE STRING can be PARSED !!!");
                break;
            }
        }

        if(j==pro[0].n)
            printf("\n\nTHE STRING can NOT be PARSED !!!");
    }

    printf("\n\n");

}

-----------------------------------------------------------------------------------------------------------------------
5-b machine code from abtract syntax tree 

#include <stdio.h>
#include <stdlib.h>


typedef struct AST AST; // Forward reference

struct AST {
  enum {
    AST_MAIN,
    AST_NUMBER,
    AST_ADD,
    AST_MUL,
  } tag;
  union {
    struct AST_MAIN { AST *body; } AST_MAIN;
    struct AST_NUMBER { int number; } AST_NUMBER;
    struct AST_ADD { AST *left; AST *right; } AST_ADD;
    struct AST_MUL { AST *left; AST *right; } AST_MUL;
  } data;
};

AST *ast_new(AST ast) {
  AST *ptr = malloc(sizeof(AST));
  if (ptr) *ptr = ast;
  return ptr;
}

void ast_free(AST *ptr) {
  AST ast = *ptr;
  switch (ast.tag) {
    case AST_MAIN: {
      struct AST_MAIN data = ast.data.AST_MAIN;
      ast_free(data.body);
      break;
    }
    case AST_NUMBER: {
      struct AST_NUMBER data = ast.data.AST_NUMBER;
      break;
    }
    case AST_ADD: {
      struct AST_ADD data = ast.data.AST_ADD;
      ast_free(data.left);
      ast_free(data.right);
      break;
    }
    case AST_MUL: {
      struct AST_MUL data = ast.data.AST_MUL;
      ast_free(data.left);
      ast_free(data.right);
      break;
    }
  }
  free(ptr);
}

#define AST_NEW(tag, ...) ast_new((AST){tag, {.tag=(struct tag){__VA_ARGS__}}})

void ast_print(AST *ptr) {
  AST ast = *ptr;
  switch (ast.tag) {
    case AST_MAIN: {
      struct AST_MAIN data = ast.data.AST_MAIN;
      printf("main() = ");
      ast_print(data.body);
      return;
    }
    case AST_NUMBER: {
      struct AST_NUMBER data = ast.data.AST_NUMBER;
      printf("%d", data.number);
      return;
    }
    case AST_ADD: {
      struct AST_ADD data = ast.data.AST_ADD;
      printf("(");
      ast_print(data.left);
      printf(" + ");
      ast_print(data.right);
      printf(")");
      return;
    }
    case AST_MUL: {
      struct AST_MUL data = ast.data.AST_MUL;
      printf("(");
      ast_print(data.left);
      printf(" * ");
      ast_print(data.right);
      printf(")");
      return;
    }
  }
}

#define emitf printf

void ast_emit(AST *ptr) {
  AST ast = *ptr;
  switch (ast.tag) {
    case AST_MAIN: {
      struct AST_MAIN data = ast.data.AST_MAIN;
      emitf(".global _main\n");
      emitf("_main:\n"); 
      ast_emit(data.body);
      emitf("  ret\n");
      emitf("\n");
      return;
    }
    case AST_NUMBER: {
      struct AST_NUMBER data = ast.data.AST_NUMBER;
      emitf("  mov rax, %d\n", data.number);
      return;
    }
    case AST_ADD: {
      struct AST_ADD data = ast.data.AST_ADD;
      ast_emit(data.left);
      emitf("  push rax\n");
      ast_emit(data.right);
      emitf("  pop rbx\n");
      emitf("  add rax, rbx\n");
      return;
    }
    case AST_MUL: {
      struct AST_MUL data = ast.data.AST_MUL;
      ast_emit(data.left);
      emitf("  push rax\n");
      ast_emit(data.right);
      emitf("  pop rbx\n");
      emitf("  mul rbx\n");
      return;
    }
  }
}

int main() {
  // main() = 4 + 2 * 10 + 3 * (5 + 1)
  AST *term = AST_NEW(AST_MAIN,
    AST_NEW(AST_ADD,
      AST_NEW(AST_NUMBER, 4),
      AST_NEW(AST_ADD,
        AST_NEW(AST_MUL, 
          AST_NEW(AST_NUMBER, 2), 
          AST_NEW(AST_NUMBER, 10),
        ),
        AST_NEW(AST_MUL,
          AST_NEW(AST_NUMBER, 3),
          AST_NEW(AST_ADD,
            AST_NEW(AST_NUMBER, 5),
            AST_NEW(AST_NUMBER, 1),
          ),
        ),
      ),
    ),
  );
  printf("/* "); ast_print(term); printf(" */\n"); 
  ast_emit(term);
  ast_free(term);
}

____________________________________________________________________________________________________________________________________________

6-a  C code to implement Context Free Grammar(CFG)



C code to implement Context Free Grammar(CFG)
/* C program to implement CFG(Context Free Grammar). */

#include<stdio.h>
#include<string.h>

int i,j,k,l,m,n=0,o,p,nv,z=0,t,x=0;
char str[10],temp[20],temp2[20],temp3[20];

struct prod
{
    char lhs[10],rhs[10][10];
    int n;
}pro[10];

void findter()
{
    for(k=0;k<n;k++)
    {
        if(temp[i]==pro[k].lhs[0])
        {
            for(t=0;t<pro[k].n;t++)
            {
                for(l=0;l<20;l++)
                    temp2[l]='\0';
                for(l=i+1;l<strlen(temp);l++)
                    temp2[l-i-1]=temp[l];
                for(l=i;l<20;l++)
                    temp[l]='\0';
                for(l=0;l<strlen(pro[k].rhs[t]);l++)
                    temp[i+l]=pro[k].rhs[t][l];
                strcat(temp,temp2);
                if(str[i]==temp[i])
                    return;
                else if(str[i]!=temp[i] && temp[i]>=65 && temp[i]<=90)
                    break;
            }
            break;
        }
    }
    if(temp[i]>=65 && temp[i]<=90)
        findter();
}

void main()
{
    FILE *f;
    clrscr();

    for(i=0;i<10;i++)
        pro[i].n=0;

    f=fopen("input.txt","r");
    while(!feof(f))
    {
        fscanf(f,"%s",pro[n].lhs);
        if(n>0)
        {
            if( strcmp(pro[n].lhs,pro[n-1].lhs) == 0 )
            {
                pro[n].lhs[0]='\0';
                fscanf(f,"%s",pro[n-1].rhs[pro[n-1].n]);
                pro[n-1].n++;
                continue;
            }
        }
        fscanf(f,"%s",pro[n].rhs[pro[n].n]);
        pro[n].n++;
        n++;
    }
    n--;

    printf("\n\nTHE GRAMMAR IS AS FOLLOWS\n\n");
    for(i=0;i<n;i++)
        for(j=0;j<pro[i].n;j++)
            printf("%s -> %s\n",pro[i].lhs,pro[i].rhs[j]);

    while(1)
    {
        for(l=0;l<10;l++)
            str[0]=NULL;

        printf("\n\nENTER ANY STRING ( 0 for EXIT ) : ");
        scanf("%s",str);
        if(str[0]=='0')
            exit(1);

        for(j=0;j<pro[0].n;j++)
        {
            for(l=0;l<20;l++)
                temp[l]=NULL;
            strcpy(temp,pro[0].rhs[j]);

            m=0;
            for(i=0;i<strlen(str);i++)
            {
                if(str[i]==temp[i])
                    m++;
                else if(str[i]!=temp[i] && temp[i]>=65 && temp[i]<=90)
                {
                    findter();
                    if(str[i]==temp[i])
                        m++;
                }
                else if( str[i]!=temp[i] && (temp[i]<65 || temp[i]>90) )
                    break;
            }

            if(m==strlen(str) && strlen(str)==strlen(temp))
            {
                printf("\n\nTHE STRING can be PARSED !!!");
                break;
            }
        }

        if(j==pro[0].n)
            printf("\n\nTHE STRING can NOT be PARSED !!!");
    }

    getch();
}

____--------------------------------------------------------------------------------------------------------------------------------------

6-b write a program for construction of minimized DFA from a given regular expression using C.


#include         

#include

#define STATES 50

struct Dstate

{

char name;

char StateString[STATES+1];

char trans[10];    

int is_final;

}Dstates[50];

struct tran

{

char sym;

int tostates[50];

int notran;

};

struct state

{

int no;

struct tran tranlist[50];

};

int stackA[100],stackB[100],c[100],Cptr=-1,Aptr=-1,Bptr=-1;

struct state States[10];

char temp[STATES+1],inp[10];

int nos,noi,nof,j,k,nods=-1;


void pushA(int z)

{

stackA[++Aptr]=z;

}

void pushB(int z)

{

stackB[++Bptr]=z;

}




int popA()

{

return stackA[Aptr--];

}

void copy(int i)

{

char temp[STATES+1]=" ";

int k=0;

Bptr=-1;

strcpy(temp,Dstates[i].StateString);

while(temp[k]!='\0')

{

pushB(temp[k]-'0');

k++;

}

}

int popB()

{

return stackB[Bptr--];

}

int peekA()

{

return stackA[Aptr];

}

int peekB()

{

return stackA[Bptr];

}

int seek(int arr[],int ptr,int s)

{

int i;

for(i=0;i<=ptr;i++)

{

if(s==arr[i])

return 1;

}

return 0;

}

void sort()

{

int i,j,temp;

for(i=0;i

{

for(j=0;j<(Bptr-i);j++)

{

if(stackB[j]>stackB[j+1])

{

temp=stackB[j];   

stackB[j]=stackB[j+1];

stackB[j+1]=temp;

}

}

  }

    }

void tostring()

{

int i=0;

sort();        

for(i=0;i<=Bptr;i++)

{      

temp[i]=stackB[i]+'0';

}

temp[i]='\0';

}

void display_DTran()

{

int i,j;

printf("\n\t\t DFA transition table");

printf("\n\t\t ---------------------------------------------- ");

printf("\n States \tString \tInputs\n");

for(i=0;i

{

printf("\t %c",inp[i]);

}

printf("\n\t ------------------------------------------------- ");

for(i=0;i

{

if(Dstates[i].is_final==0)

printf("\n%c",Dstates[i].name);

else

printf("\n*%c",Dstates[i].name);

printf("\t%s",Dstates[i].StateString);

for(j=0;j

{

printf("\t%c",Dstates[i].trans[j]);

}

    }

     printf("\n");

}

void move(int st,int j)

{

int ctr=0;

while(ctr

{

pushA(States[st].tranlist[j].tostates[ctr++]);

}

}

void lambda_closure(int st)

{

int ctr=0,in_state=st,curst=st,chk;

while(Aptr!=-1)

{

curst=popA();

ctr=0;

in_state=curst;

while(ctr<=States[curst].tranlist[noi].notran)

{

chk=seek(stackB,Bptr,in_state);

if(chk==0)

pushB(in_state);

in_state=States[curst].tranlist[noi].tostates[ctr++];

chk=seek(stackA,Aptr,in_state);

if(chk==0 && ctr<=States[curst].tranlist[noi].notran)

pushA(in_state);

}

     }

}

void main()

{

int i,final[20],start,fin=0;

char c,ans,st[20];

printf("\n Enter no of states in NFA:");

scanf("%d",&nos);

for(i=0;i

{

States[i].no=i;

}

printf("\n Enter the start states:");

scanf("%d",&start);

printf("Enter the no of final states:");

scanf("%d",&nof);

printf("Enter the final states:\n");

for(i=0;i

scanf("%d",&final[i]);

printf("\n Enter the no of input symbols:");

scanf("%d",&noi);

c=getchar();

printf("Enter the input symbols:\n");

for(i=0;i

{

scanf("%c",&inp[i]);

c=getchar();

}

//g1inp[i]='e';

inp=[i]=’e’;

printf("\n Enter the transitions:(-1 to stop)\n");

for(i=0;i

{

for(j=0;j<=noi;j++)

{

States[i].tranlist[j].sym=inp[j];

k=0;

ans='y';

while(ans=='y')

{

printf("move(%d,%c);",i,inp[j]);

scanf("%d",&States[i].tranlist[j].tostates[k++]);

if((States[i].tranlist[j].tostates[k-1]==-1))

{

k--;

ans='n';

break;

                      }

               }

States[i].tranlist[j].notran=k;

               }

}

i=0;nods=0,fin=0;

pushA(start);

lambda_closure(peekA());

tostring();

Dstates[nods].name='A';

nods++;

strcpy(Dstates[0].StateString,temp);

while(i

{

for(j=0;j

{

fin=0;

copy(i);

while(Bptr!=-1)

{

move(popB(),j);

}




while(Aptr!=-1)

lambda_closure(peekA());

tostring();

for(k=0;k

{

if((strcmp(temp,Dstates[k].StateString)==0))

{

Dstates[i].trans[j]=Dstates[k].name;

break;

}

}

if(k==nods)

{

nods++;

for(k=0;k

{

fin=seek(stackB,Bptr,final[k]);

if(fin==1)

{

Dstates[nods-1].is_final=1;

break;

}

    }

strcpy(Dstates[nods-1].StateString,temp);

Dstates[nods-1].name='A'+nods-1;

Dstates[i].trans[j]=Dstates[nods-1].name;

}

}

i++;

}

display_DTran();

}


-__________________________________________________________________________________________________________________________________________________




7-a
/* Lex Program that copies a C program, replacing each instance of the keyword float with double */
/* Definations */
%{
	
	
	
	/* standard io for io functions, string.h for string functions and stdlib for exit()*/
	#include <stdio.h>  
	#include <string.h>
	#include <stdlib.h> 
	/* String variable to store string line by line*/
	char string[200];
%}

/* Rules */
/* Copy a line to the output file */
/* Replace sequence of white space by a single blank */
/* Copy everything else as it is to the line*/
/*Copy a line to the output file at the end*/ 
%%
[\n]		{fprintf(yyout, "%s\n", string); string[0] = '\0'; }
"float"		{fprintf(yyout, "%s", string); string[0] = '\0'; fprintf(yyout, "%s", "double"); }
.			strcat(string, yytext);
<<EOF>>		{ fprintf(yyout, "%s", string); return 0; } 
%%

int main()
{
	extern FILE *yyin, *yyout;
	char filename[100]; 
	printf("This Program is going copy a C program, replacing each instance of the keyword float with double!\nEnter the name of the C file to copy:\t");
	scanf("%s", filename);
	/* Opening file to read */
	yyin = fopen(filename, "r");
	if (yyin == NULL){
		printf("Cannot open file %s\n", filename);
	    exit(0);
	}
	printf("Enter the name of the C file to open for writing:\t");
	scanf("%s", filename);
	/* Opening file to write */
	yyout = fopen(filename, "w");
	if (yyout == NULL){
		printf("Cannot open file %s\n", filename);
	    exit(1);
	}
	yylex();
}

int yywrap(void)
{
	return 1;
}







_-------------------------------------------------------------------------------------------------------------------------

7-b 
write a program to compute first for the folowing grammer


#include <ctype.h>
#include <stdio.h>
#include <string.h>
 
// Functions to calculate Follow
void followfirst(char, int, int);
void follow(char c);
 
// Function to calculate First
void findfirst(char, int, int);
 
int count, n = 0;
 
// Stores the final result
// of the First Sets
char calc_first[10][100];
 
// Stores the final result
// of the Follow Sets
char calc_follow[10][100];
int m = 0;
 
// Stores the production rules
char production[10][10];
char f[10], first[10];
int k;
char ck;
int e;
 
int main(int argc, char** argv)
{
    int jm = 0;
    int km = 0;
    int i, choice;
    char c, ch;
    count = 8;
 
    // The Input grammar
    strcpy(production[0], "X=TnS");
    strcpy(production[1], "X=Rm");
    strcpy(production[2], "T=q");
    strcpy(production[3], "T=#");
    strcpy(production[4], "S=p");
    strcpy(production[5], "S=#");
    strcpy(production[6], "R=om");
    strcpy(production[7], "R=ST");
 
    int kay;
    char done[count];
    int ptr = -1;
 
    // Initializing the calc_first array
    for (k = 0; k < count; k++) {
        for (kay = 0; kay < 100; kay++) {
            calc_first[k][kay] = '!';
        }
    }
    int point1 = 0, point2, xxx;
 
    for (k = 0; k < count; k++) {
        c = production[k][0];
        point2 = 0;
        xxx = 0;
 
        // Checking if First of c has
        // already been calculated
        for (kay = 0; kay <= ptr; kay++)
            if (c == done[kay])
                xxx = 1;
 
        if (xxx == 1)
            continue;
 
        // Function call
        findfirst(c, 0, 0);
        ptr += 1;
 
        // Adding c to the calculated list
        done[ptr] = c;
        printf("\n First(%c) = { ", c);
        calc_first[point1][point2++] = c;
 
        // Printing the First Sets of the grammar
        for (i = 0 + jm; i < n; i++) {
            int lark = 0, chk = 0;
 
            for (lark = 0; lark < point2; lark++) {
 
                if (first[i] == calc_first[point1][lark]) {
                    chk = 1;
                    break;
                }
            }
            if (chk == 0) {
                printf("%c, ", first[i]);
                calc_first[point1][point2++] = first[i];
            }
        }
        printf("}\n");
        jm = n;
        point1++;
    }
    printf("\n");
    printf("-----------------------------------------------"
           "\n\n");
    char donee[count];
    ptr = -1;
 
    // Initializing the calc_follow array
    for (k = 0; k < count; k++) {
        for (kay = 0; kay < 100; kay++) {
            calc_follow[k][kay] = '!';
        }
    }
    point1 = 0;
    int land = 0;
    for (e = 0; e < count; e++) {
        ck = production[e][0];
        point2 = 0;
        xxx = 0;
 
        // Checking if Follow of ck
        // has already been calculated
        for (kay = 0; kay <= ptr; kay++)
            if (ck == donee[kay])
                xxx = 1;
 
        if (xxx == 1)
            continue;
        land += 1;
 
        // Function call
        follow(ck);
        ptr += 1;
 
        // Adding ck to the calculated list
        donee[ptr] = ck;
        printf(" Follow(%c) = { ", ck);
        calc_follow[point1][point2++] = ck;
 
        // Printing the Follow Sets of the grammar
        for (i = 0 + km; i < m; i++) {
            int lark = 0, chk = 0;
            for (lark = 0; lark < point2; lark++) {
                if (f[i] == calc_follow[point1][lark]) {
                    chk = 1;
                    break;
                }
            }
            if (chk == 0) {
                printf("%c, ", f[i]);
                calc_follow[point1][point2++] = f[i];
            }
        }
        printf(" }\n\n");
        km = m;
        point1++;
    }
}
 
void follow(char c)
{
    int i, j;
 
    // Adding "$" to the follow
    // set of the start symbol
    if (production[0][0] == c) {
        f[m++] = '$';
    }
    for (i = 0; i < 10; i++) {
        for (j = 2; j < 10; j++) {
            if (production[i][j] == c) {
                if (production[i][j + 1] != '\0') {
                    // Calculate the first of the next
                    // Non-Terminal in the production
                    followfirst(production[i][j + 1], i,
                                (j + 2));
                }
 
                if (production[i][j + 1] == '\0'
                    && c != production[i][0]) {
                    // Calculate the follow of the
                    // Non-Terminal in the L.H.S. of the
                    // production
                    follow(production[i][0]);
                }
            }
        }
    }
}
 
void findfirst(char c, int q1, int q2)
{
    int j;
 
    // The case where we
    // encounter a Terminal
    if (!(isupper(c))) {
        first[n++] = c;
    }
    for (j = 0; j < count; j++) {
        if (production[j][0] == c) {
            if (production[j][2] == '#') {
                if (production[q1][q2] == '\0')
                    first[n++] = '#';
                else if (production[q1][q2] != '\0'
                         && (q1 != 0 || q2 != 0)) {
                    // Recursion to calculate First of New
                    // Non-Terminal we encounter after
                    // epsilon
                    findfirst(production[q1][q2], q1,
                              (q2 + 1));
                }
                else
                    first[n++] = '#';
            }
            else if (!isupper(production[j][2])) {
                first[n++] = production[j][2];
            }
            else {
                // Recursion to calculate First of
                // New Non-Terminal we encounter
                // at the beginning
                findfirst(production[j][2], j, 3);
            }
        }
    }
}
 
void followfirst(char c, int c1, int c2)
{
    int k;
 
    // The case where we encounter
    // a Terminal
    if (!(isupper(c)))
        f[m++] = c;
    else {
        int i = 0, j = 1;
        for (i = 0; i < count; i++) {
            if (calc_first[i][0] == c)
                break;
        }
 
        // Including the First set of the
        // Non-Terminal in the Follow of
        // the original query
        while (calc_first[i][j] != '!') {
            if (calc_first[i][j] != '#') {
                f[m++] = calc_first[i][j];
            }
            else {
                if (production[c1][c2] == '\0') {
                    // Case where we reach the
                    // end of a production
                    follow(production[c1][0]);
                }
                else {
                    // Recursion to the next symbol
                    // in case we encounter a "#"
                    followfirst(production[c1][c2], c1,
                                c2 + 1);
                }
            }
            j++;
        }
    }
}






_____________________________________________________________________________________________________________________________________



8-a
lex program to count number of vowels and consonants from an input file and write the results to a file



%{
 int ac=0;
 int bc=0;
%}
%%
[aeiouAEIOU] {ac++;}
[a-zA-z] {bc++;}
%%
int yywrap() {}
int main()
{
   printf("Enter the string \n");
   yylex();
   printf("THe number of vowel are %d\n",ac);
   printf("The number of consonant is %d",bc);
   return 0;
}

--------------------------------------------------------------------------------------------------------------


8-b 
write a program to compute first for thefollowing grammer ictss




#include <ctype.h>
#include <stdio.h>
#include <string.h>
 
// Functions to calculate Follow
void followfirst(char, int, int);
void follow(char c);
 
// Function to calculate First
void findfirst(char, int, int);
 
int count, n = 0;
 
// Stores the final result
// of the First Sets
char calc_first[10][100];
 
// Stores the final result
// of the Follow Sets
char calc_follow[10][100];
int m = 0;
 
// Stores the production rules
char production[10][10];
char f[10], first[10];
int k;
char ck;
int e;
 
int main(int argc, char** argv)
{
    int jm = 0;
    int km = 0;
    int i, choice;
    char c, ch;
    count = 8;
 
    // The Input grammar
    strcpy(production[0], "X=TnS");
    strcpy(production[1], "X=Rm");
    strcpy(production[2], "T=q");
    strcpy(production[3], "T=#");
    strcpy(production[4], "S=p");
    strcpy(production[5], "S=#");
    strcpy(production[6], "R=om");
    strcpy(production[7], "R=ST");
 
    int kay;
    char done[count];
    int ptr = -1;
 
    // Initializing the calc_first array
    for (k = 0; k < count; k++) {
        for (kay = 0; kay < 100; kay++) {
            calc_first[k][kay] = '!';
        }
    }
    int point1 = 0, point2, xxx;
 
    for (k = 0; k < count; k++) {
        c = production[k][0];
        point2 = 0;
        xxx = 0;
 
        // Checking if First of c has
        // already been calculated
        for (kay = 0; kay <= ptr; kay++)
            if (c == done[kay])
                xxx = 1;
 
        if (xxx == 1)
            continue;
 
        // Function call
        findfirst(c, 0, 0);
        ptr += 1;
 
        // Adding c to the calculated list
        done[ptr] = c;
        printf("\n First(%c) = { ", c);
        calc_first[point1][point2++] = c;
 
        // Printing the First Sets of the grammar
        for (i = 0 + jm; i < n; i++) {
            int lark = 0, chk = 0;
 
            for (lark = 0; lark < point2; lark++) {
 
                if (first[i] == calc_first[point1][lark]) {
                    chk = 1;
                    break;
                }
            }
            if (chk == 0) {
                printf("%c, ", first[i]);
                calc_first[point1][point2++] = first[i];
            }
        }
        printf("}\n");
        jm = n;
        point1++;
    }
    printf("\n");
    printf("-----------------------------------------------"
           "\n\n");
    char donee[count];
    ptr = -1;
 
    // Initializing the calc_follow array
    for (k = 0; k < count; k++) {
        for (kay = 0; kay < 100; kay++) {
            calc_follow[k][kay] = '!';
        }
    }
    point1 = 0;
    int land = 0;
    for (e = 0; e < count; e++) {
        ck = production[e][0];
        point2 = 0;
        xxx = 0;
 
        // Checking if Follow of ck
        // has already been calculated
        for (kay = 0; kay <= ptr; kay++)
            if (ck == donee[kay])
                xxx = 1;
 
        if (xxx == 1)
            continue;
        land += 1;
 
        // Function call
        follow(ck);
        ptr += 1;
 
        // Adding ck to the calculated list
        donee[ptr] = ck;
        printf(" Follow(%c) = { ", ck);
        calc_follow[point1][point2++] = ck;
 
        // Printing the Follow Sets of the grammar
        for (i = 0 + km; i < m; i++) {
            int lark = 0, chk = 0;
            for (lark = 0; lark < point2; lark++) {
                if (f[i] == calc_follow[point1][lark]) {
                    chk = 1;
                    break;
                }
            }
            if (chk == 0) {
                printf("%c, ", f[i]);
                calc_follow[point1][point2++] = f[i];
            }
        }
        printf(" }\n\n");
        km = m;
        point1++;
    }
}
 
void follow(char c)
{
    int i, j;
 
    // Adding "$" to the follow
    // set of the start symbol
    if (production[0][0] == c) {
        f[m++] = '$';
    }
    for (i = 0; i < 10; i++) {
        for (j = 2; j < 10; j++) {
            if (production[i][j] == c) {
                if (production[i][j + 1] != '\0') {
                    // Calculate the first of the next
                    // Non-Terminal in the production
                    followfirst(production[i][j + 1], i,
                                (j + 2));
                }
 
                if (production[i][j + 1] == '\0'
                    && c != production[i][0]) {
                    // Calculate the follow of the
                    // Non-Terminal in the L.H.S. of the
                    // production
                    follow(production[i][0]);
                }
            }
        }
    }
}
 
void findfirst(char c, int q1, int q2)
{
    int j;
 
    // The case where we
    // encounter a Terminal
    if (!(isupper(c))) {
        first[n++] = c;
    }
    for (j = 0; j < count; j++) {
        if (production[j][0] == c) {
            if (production[j][2] == '#') {
                if (production[q1][q2] == '\0')
                    first[n++] = '#';
                else if (production[q1][q2] != '\0'
                         && (q1 != 0 || q2 != 0)) {
                    // Recursion to calculate First of New
                    // Non-Terminal we encounter after
                    // epsilon
                    findfirst(production[q1][q2], q1,
                              (q2 + 1));
                }
                else
                    first[n++] = '#';
            }
            else if (!isupper(production[j][2])) {
                first[n++] = production[j][2];
            }
            else {
                // Recursion to calculate First of
                // New Non-Terminal we encounter
                // at the beginning
                findfirst(production[j][2], j, 3);
            }
        }
    }
}
 
void followfirst(char c, int c1, int c2)
{
    int k;
 
    // The case where we encounter
    // a Terminal
    if (!(isupper(c)))
        f[m++] = c;
    else {
        int i = 0, j = 1;
        for (i = 0; i < count; i++) {
            if (calc_first[i][0] == c)
                break;
        }
 
        // Including the First set of the
        // Non-Terminal in the Follow of
        // the original query
        while (calc_first[i][j] != '!') {
            if (calc_first[i][j] != '#') {
                f[m++] = calc_first[i][j];
            }
            else {
                if (production[c1][c2] == '\0') {
                    // Case where we reach the
                    // end of a production
                    follow(production[c1][0]);
                }
                else {
                    // Recursion to the next symbol
                    // in case we encounter a "#"
                    followfirst(production[c1][c2], c1,
                                c2 + 1);
                }
            }
            j++;
        }
    }
}






8-3
write a program to construct predictive parsing table for the following grammar ictss




#include <stdio.h>
#include <string.h>
 
char prol[7][10] = { "S", "A", "A", "B", "B", "C", "C" };
char pror[7][10] = { "A", "Bb", "Cd", "aB", "@", "Cc", "@" };
char prod[7][10] = { "S->A", "A->Bb", "A->Cd", "B->aB", "B->@", "C->Cc", "C->@" };
char first[7][10] = { "abcd", "ab", "cd", "a@", "@", "c@", "@" };
char follow[7][10] = { "$", "$", "$", "a$", "b$", "c$", "d$" };
char table[5][6][10];
 
int numr(char c)
{
   switch (c)
   {
      case 'S':
         return 0;
 
      case 'A':
         return 1;
 
      case 'B':
         return 2;
 
      case 'C':
         return 3;
 
      case 'a':
         return 0;
 
      case 'b':
         return 1;
 
      case 'c':
         return 2;
 
      case 'd':
         return 3;
 
      case '$':
         return 4;
   }
 
   return (2);
}
 
int main()
{
   int i, j, k;
 
   for (i = 0; i < 5; i++)
      for (j = 0; j < 6; j++)
         strcpy(table[i][j], " ");
 
   printf("The following grammar is used for Parsing Table:\n");
 
   for (i = 0; i < 7; i++)
      printf("%s\n", prod[i]);
 
   printf("\nPredictive parsing table:\n");
 
   fflush(stdin);
 
   for (i = 0; i < 7; i++)
   {
      k = strlen(first[i]);
      for (j = 0; j < 10; j++)
         if (first[i][j] != '@')
            strcpy(table[numr(prol[i][0]) + 1][numr(first[i][j]) + 1], prod[i]);
   }
 
   for (i = 0; i < 7; i++)
   {
      if (strlen(pror[i]) == 1)
      {
         if (pror[i][0] == '@')
         {
            k = strlen(follow[i]);
            for (j = 0; j < k; j++)
               strcpy(table[numr(prol[i][0]) + 1][numr(follow[i][j]) + 1], prod[i]);
         }
      }
   }
 
   strcpy(table[0][0], " ");
 
   strcpy(table[0][1], "a");
 
   strcpy(table[0][2], "b");
 
   strcpy(table[0][3], "c");
 
   strcpy(table[0][4], "d");
 
   strcpy(table[0][5], "$");
 
   strcpy(table[1][0], "S");
 
   strcpy(table[2][0], "A");
 
   strcpy(table[3][0], "B");
 
   strcpy(table[4][0], "C");
 
   printf("\n--------------------------------------------------------\n");
 
   for (i = 0; i < 5; i++)
      for (j = 0; j < 6; j++)
      {
         printf("%-10s", table[i][j]);
         if (j == 5)
            printf("\n--------------------------------------------------------\n");
      }
}


